---
layout: post
title: Redux
date: '2016-05-18 15:37:01 +0800'
categories: Architecture
---

# Redux

Redux 是 JavaScript 状态容器，提供可预测化的状态管理。

## 动机

前端复杂性根本原因： `变化` + `异步`

React 试图在视图层禁止异步和直接操作 DOM 来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。

Redux 试图让 state 的变化变得可预测

## 三大原则

- 单一数据源

  整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。

- state 是只读的

  惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。

  这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。

- 使用纯函数来执行修改

  为了描述 action 如何改变 state tree ，你需要编写 reducers。

  Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。

## Action

Action 是把数据传到 store 的有效载荷。它是 store 数据的唯一来源。一般通过 store.dispatch() 将 action 传到 store。

## Reducer

reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。

> (previousState, action) => newState

之所以称作 reducer 是因为它将被传递给 `Array.prototype.reduce(reducer, ?initialValue)`方法。保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作：

- 修改传入参数；

- 执行有副作用的操作，如 API 请求和路由跳转；

- 调用非纯函数，如 Date.now() 或 Math.random()。

需要谨记 reducer 一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。

reducer 中不要修改 state，同时，在 default 情况下返回旧的 state。

注意每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。

combineReducers() 所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中的一部分数据并处理，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。

## Store

Action 描述 "发生了什么"，Reducer 根据 action 更新 state，Store 就是把它们联系到一起的对象。

Store 有以下职责：

- 维持应用的 state；
- 提供 getState() 方法获取 state；
- 提供 dispatch(action) 方法更新 state；
- 通过 subscribe(listener) 注册监听器;
- 通过 subscribe(listener) 返回的函数注销监听器。

Redux 应用只有一个`单一的 store`。当需要拆分数据处理逻辑时，应该使用 `reducer 组合` 而不是创建多个 store。

## 数据流

**严格的单向数据流** 是 Redux 架构的设计核心。

Redux 应用中数据的生命周期遵循下面 4 个步骤：

- 调用 store.dispatch(action)。
- Redux store 调用传入的 reducer 函数。
- 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。
- Redux store 保存了根 reducer 返回的完整 state 树。

--------------------------------------------------------------------------------

Redux 提供了：

1. 存放应用程序状态的容器
2. 一种把 `action` 分发到状态修改器的机制，也就是 `reducer` 函数
3. 状态监听机制

往 `createStore` 传 `Reducer` 的过程就是给 `Redux` 绑定 `action` 处理函数（也就是 `Reducer`）的过程。

Reducer was called with args `[undefined, {type: '@@redux/INIT'}]`

`combineReducers` 接收一个对象并返回一个函数，当 `combineReducers` 被调用时，它会去调用每个 `reducer`，并把返回的每一块 state 重新组合成一个大 state 对象（也就是 Redux 中的 `Store`）。

`combineReducers` 间接构造了应用的 **_状态树_**。

## store、reducer、action关联

- `store`在这里代表的是数据模型，内部维护了一个state变量，用例描述应用的状态。store有两个核心方法，分别是`getState`、`dispatch`。前者用来获取store的状态（state），后者用来修改store的状态。
- `action`对行为（如用户行为）的抽象，在redux里是一个普通的js对象。redux对action的约定比较弱，除了一点，action必须有一个type字段来标识这个行为的类型。
- `reducer`一个普通的函数，用来修改store的状态。传入两个参数 state、action。其中，state为当前的状态（可通过store.getState()获得），而action为当前触发的行为（通过store.dispatch(action)调用触发）。reducer(state, action) 返回的值，就是store最新的state值。

## Redux 流转图

![redux_flowchart](resources/redux_flowchart.png)

## DevTools

详情请参考：

- <https://github.com/gaearon/redux-devtools>
- <https://github.com/zalmoxisus/redux-devtools-extension>

**安装**

[Chrome Extention](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd)

**配置**

在程序源码中，将

```javascript
let store = createStore(reducer);
```

替换为

```javascript
let store = createStore(reducer, window.devToolsExtension && window.devToolsExtension());
```
